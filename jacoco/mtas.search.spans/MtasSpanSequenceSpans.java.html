<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MtasSpanSequenceSpans.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.search.spans</a> &gt; <span class="el_source">MtasSpanSequenceSpans.java</span></div><h1>MtasSpanSequenceSpans.java</h1><pre class="source lang-java linenums">package mtas.search.spans;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

import mtas.search.spans.MtasSpanSequenceQuery.MtasSpanSequenceQuerySpans;
import mtas.search.spans.util.MtasIgnoreItem;
import mtas.search.spans.util.MtasSpans;

import org.apache.lucene.search.spans.SpanCollector;
import org.apache.lucene.search.spans.Spans;

/**
 * The Class MtasSpanSequenceSpans.
 */
<span class="pc bpc" id="L20" title="1 of 2 branches missed.">public class MtasSpanSequenceSpans extends Spans implements MtasSpans {</span>

  /** The queue spans. */
  private List&lt;QueueItem&gt; queueSpans;

  /** The ignore item. */
  private MtasIgnoreItem ignoreItem;

  /** The queue matches. */
  private List&lt;Match&gt; queueMatches;

  /** The doc id. */
  private int docId;
  
  /** The current position. */
  private int currentPosition;

  /** The cost. */
  private long cost;

  /** The current match. */
  Match currentMatch;

  /**
   * Instantiates a new mtas span sequence spans.
   *
   * @param setSequenceSpans the set sequence spans
   * @param ignoreSpans the ignore spans
   * @param maximumIgnoreLength the maximum ignore length
   */
  public MtasSpanSequenceSpans(
      List&lt;MtasSpanSequenceQuerySpans&gt; setSequenceSpans, Spans ignoreSpans,
      Integer maximumIgnoreLength) {
<span class="fc" id="L53">    super();</span>
<span class="fc" id="L54">    docId = -1;</span>
<span class="fc" id="L55">    queueSpans = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L56">    queueMatches = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">    for (MtasSpanSequenceQuerySpans sequenceSpans : setSequenceSpans) {</span>
<span class="fc" id="L58">      queueSpans.add(new QueueItem(sequenceSpans));</span>
<span class="fc" id="L59">    }</span>
<span class="fc" id="L60">    ignoreItem = new MtasIgnoreItem(ignoreSpans, maximumIgnoreLength);</span>
<span class="fc" id="L61">    resetQueue();</span>
<span class="fc" id="L62">    computeCosts();</span>
<span class="fc" id="L63">  }</span>

  /**
   * Compute costs.
   */
  private void computeCosts() {
<span class="fc" id="L69">    cost = Long.MAX_VALUE;</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">    for (QueueItem item : queueSpans) {</span>
<span class="fc" id="L71">      cost = Math.min(cost, item.sequenceSpans.spans.cost());</span>
<span class="fc" id="L72">    }</span>
<span class="fc" id="L73">  }</span>

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.Spans#nextStartPosition()
   */
  @Override
  public int nextStartPosition() throws IOException {
<span class="fc bfc" id="L82" title="All 2 branches covered.">    if (findMatches()) {</span>
<span class="fc" id="L83">      currentMatch = queueMatches.get(0);</span>
<span class="fc" id="L84">      currentPosition = currentMatch.startPosition();</span>
<span class="fc" id="L85">      queueMatches.remove(0);</span>
<span class="fc" id="L86">      return currentMatch.startPosition();</span>
    } else {
<span class="fc" id="L88">      currentMatch = new Match(NO_MORE_POSITIONS, NO_MORE_POSITIONS);</span>
<span class="fc" id="L89">      currentPosition = NO_MORE_POSITIONS;</span>
<span class="fc" id="L90">      return NO_MORE_POSITIONS;</span>
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.Spans#startPosition()
   */
  @Override
  public int startPosition() {
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">    if (currentMatch == null) {</span>
<span class="nc" id="L102">      return -1;</span>
    } else {
<span class="fc" id="L104">      return currentMatch.startPosition();</span>
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.Spans#endPosition()
   */
  @Override
  public int endPosition() {
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">    if (currentMatch == null) {</span>
<span class="nc" id="L116">      return -1;</span>
    } else {
<span class="fc" id="L118">      return currentMatch.endPosition();</span>
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.Spans#width()
   */
  @Override
  public int width() {
<span class="nc" id="L129">    return 0;</span>
  }

  /*
   * (non-Javadoc)
   * 
   * @see
   * org.apache.lucene.search.spans.Spans#collect(org.apache.lucene.search.spans
   * .SpanCollector)
   */
  @Override
  public void collect(SpanCollector collector) throws IOException {
<span class="nc bnc" id="L141" title="All 2 branches missed.">    for (QueueItem item : queueSpans) {</span>
<span class="nc" id="L142">      item.sequenceSpans.spans.collect(collector);</span>
<span class="nc" id="L143">    }</span>
<span class="nc" id="L144">  }</span>

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.DocIdSetIterator#docID()
   */
  @Override
  public int docID() {
<span class="fc" id="L153">    return docId;</span>
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.DocIdSetIterator#nextDoc()
   */
  @Override
  public int nextDoc() throws IOException {
<span class="fc" id="L163">    resetQueue();</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">    while (!goToNextDoc())</span>
<span class="fc" id="L165">      ;</span>
<span class="fc" id="L166">    return docId;</span>
  }

  /**
   * Go to next doc.
   *
   * @return true, if successful
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private boolean goToNextDoc() throws IOException {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">    if (docId == NO_MORE_DOCS) {</span>
<span class="nc" id="L177">      return true;</span>
    } else {
      // try to find docId with match for all items from sequence
      Integer spanDocId;
<span class="fc" id="L181">      Integer newDocId = null;</span>
<span class="fc" id="L182">      Integer minOptionalDocId = null;</span>
<span class="fc" id="L183">      boolean allItemsOptional = true;</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">      for (QueueItem item : queueSpans) {</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (!item.sequenceSpans.optional) {</span>
<span class="fc" id="L186">          allItemsOptional = false;</span>
        }
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (!item.noMoreDocs) {</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">          if (item.sequenceSpans.spans == null) {</span>
<span class="nc" id="L190">            spanDocId = NO_MORE_DOCS;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">          } else if (newDocId == null) {</span>
<span class="fc" id="L192">            spanDocId = item.sequenceSpans.spans.nextDoc();</span>
          } else {
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if (!item.sequenceSpans.optional) {</span>
<span class="fc" id="L195">              spanDocId = item.sequenceSpans.spans.advance(newDocId);</span>
            } else {
<span class="fc bfc" id="L197" title="All 2 branches covered.">              if (item.sequenceSpans.spans.docID() == -1</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">                  || newDocId &gt; item.sequenceSpans.spans.docID()) {</span>
<span class="fc" id="L199">                spanDocId = item.sequenceSpans.spans.advance(newDocId);</span>
              } else {
<span class="nc" id="L201">                spanDocId = item.sequenceSpans.spans.docID();</span>
              }
            }
          }
<span class="fc bfc" id="L205" title="All 2 branches covered.">          if (spanDocId.equals(NO_MORE_DOCS)) {</span>
<span class="fc" id="L206">            item.noMoreDocs = true;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (!item.sequenceSpans.optional) {</span>
              // a not optional span has NO_MORE_DOCS: stop
<span class="fc" id="L209">              docId = NO_MORE_DOCS;</span>
<span class="fc" id="L210">              return true;</span>
            }
<span class="fc bfc" id="L212" title="All 2 branches covered.">          } else if (!spanDocId.equals(newDocId)) {</span>
            // last found spanDocId not equal to potential new docId
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">            if (newDocId != null) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">              if (!item.sequenceSpans.optional) {</span>
                // move also previous spans to at least spanDocId
<span class="nc" id="L217">                advance(spanDocId);</span>
<span class="nc" id="L218">                return true;</span>
              }
              // define potential new docId
            } else {
<span class="fc bfc" id="L222" title="All 2 branches covered.">              if (!item.sequenceSpans.optional) {</span>
                // previous optional span with lower docId
<span class="fc bfc" id="L224" title="All 2 branches covered.">                if ((minOptionalDocId != null)</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">                    &amp;&amp; (minOptionalDocId &lt; spanDocId)) {</span>
<span class="nc" id="L226">                  advance(spanDocId);</span>
<span class="nc" id="L227">                  return true;</span>
                } else {
                  // use spanDocId as potential newDocId
<span class="fc" id="L230">                  newDocId = spanDocId;</span>
                }
              } else {
                // remember minimum docId optional spans
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">                minOptionalDocId = (minOptionalDocId == null) ? spanDocId</span>
<span class="nc" id="L235">                    : Math.min(minOptionalDocId, spanDocId);</span>
              }
            }
          }
        }
<span class="fc" id="L240">      }</span>
      // if all items are optional
<span class="pc bpc" id="L242" title="5 of 6 branches missed.">      if (allItemsOptional &amp;&amp; newDocId == null &amp;&amp; minOptionalDocId != null) {</span>
<span class="nc" id="L243">        newDocId = minOptionalDocId;</span>
      }
      // nothing found
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">      if (newDocId == null) {</span>
<span class="nc" id="L247">        docId = NO_MORE_DOCS;</span>
<span class="nc" id="L248">        return true;</span>
      } else {
<span class="fc" id="L250">        docId = newDocId;</span>
<span class="fc" id="L251">        ignoreItem.advanceToDoc(docId);</span>
        // try and glue together
<span class="fc bfc" id="L253" title="All 2 branches covered.">        if (findMatches()) {</span>
<span class="fc" id="L254">          return true;</span>
          // no matches
        } else {
<span class="fc" id="L257">          resetQueue();</span>
<span class="fc" id="L258">          return false;</span>
        }
      }
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.DocIdSetIterator#advance(int)
   */
  @Override
  public int advance(int target) throws IOException {
<span class="fc" id="L271">    resetQueue();</span>
<span class="fc" id="L272">    Integer newTarget = target;</span>
    do {
<span class="fc" id="L274">      newTarget = advanceToDoc(newTarget);</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">    } while (newTarget != null);</span>
<span class="fc" id="L276">    return docId;</span>
  }

  /**
   * Advance to doc.
   *
   * @param target the target
   * @return the integer
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private Integer advanceToDoc(int target) throws IOException {
<span class="pc bpc" id="L287" title="2 of 4 branches missed.">    if (docId == NO_MORE_DOCS || target &lt;= docId) {</span>
<span class="nc" id="L288">      return null;</span>
    } else {
      Integer spanDocId;
<span class="fc" id="L291">      Integer newDocId = target;</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">      for (QueueItem item : queueSpans) {</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (item.sequenceSpans.spans != null) {</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">          if (item.sequenceSpans.spans.docID() &lt; newDocId) {</span>
<span class="fc" id="L295">            spanDocId = item.sequenceSpans.spans.advance(newDocId);</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">            if (spanDocId.equals(NO_MORE_DOCS)) {</span>
<span class="nc" id="L297">              item.noMoreDocs = true;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">              if (!item.sequenceSpans.optional) {</span>
                // a not optional span has NO_MORE_DOCS: stop
<span class="nc" id="L300">                docId = NO_MORE_DOCS;</span>
<span class="nc" id="L301">                return null;</span>
              }
            } else {
<span class="pc bpc" id="L304" title="3 of 4 branches missed.">              if (!spanDocId.equals(newDocId) &amp;&amp; !item.sequenceSpans.optional) {</span>
                // a not optional span has nothing for newDocId: stop
<span class="nc" id="L306">                return spanDocId;</span>
              }
            }
<span class="nc bnc" id="L309" title="All 2 branches missed.">          } else if (item.sequenceSpans.spans.docID() != newDocId) {</span>
<span class="nc" id="L310">            spanDocId = item.sequenceSpans.spans.docID();</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">            if (!item.sequenceSpans.optional) {</span>
              // a not optional span seems to have nothing for newDocId: stop
<span class="nc" id="L313">              return spanDocId;</span>
            }
          }
        }
<span class="fc" id="L317">      }</span>
      // find match
<span class="fc" id="L319">      docId = newDocId;</span>
<span class="fc" id="L320">      ignoreItem.advanceToDoc(docId);</span>
      // try and glue together
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">      if (findMatches()) {</span>
<span class="fc" id="L323">        return null;</span>
        // no matches
      } else {
<span class="nc" id="L326">        resetQueue();</span>
        // try next document
<span class="nc" id="L328">        return (newDocId + 1);</span>
      }
    }
  }

  /**
   * Find matches.
   *
   * @return true, if successful
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private boolean findMatches() throws IOException {
<span class="fc" id="L340">    Boolean status = _findMatches();</span>
<span class="fc bfc" id="L341" title="All 4 branches covered.">    while (!(status || (currentPosition == NO_MORE_POSITIONS))) {</span>
<span class="fc" id="L342">      status = _findMatches();</span>
    }
<span class="fc" id="L344">    return status;</span>
  }

  /**
   * Find matches.
   *
   * @return true, if successful
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private boolean _findMatches() throws IOException {
    // queue not empty
<span class="fc bfc" id="L355" title="All 2 branches covered.">    if (!queueMatches.isEmpty()) {</span>
<span class="fc" id="L356">      return true;</span>
      // no more matches to be found
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">    } else if (currentPosition == NO_MORE_POSITIONS) {</span>
<span class="nc" id="L359">      return false;</span>
      // try to find matches
    } else {
      // subMatches: try to build matches while collecting
<span class="fc" id="L363">      Integer subMatchesStartPosition = null;</span>
<span class="fc" id="L364">      Boolean subMatchesOptional = true;</span>
<span class="fc" id="L365">      List&lt;Match&gt; subMatchesQueue = new ArrayList&lt;&gt;();</span>
      // minimum startPosition previous, used to set lower boundary on
      // startPosition next
<span class="fc" id="L368">      Integer minStartPositionPrevious = null;</span>
      // maximum endPosition previous, used to set upper boundary on
      // startPosition next
<span class="fc" id="L371">      Integer maxEndPositionPrevious = null;</span>
      // other variables
<span class="fc" id="L373">      Integer minStartPositionNext = null;</span>
<span class="fc" id="L374">      Integer minStartPosition = null;</span>
<span class="fc" id="L375">      Integer minOptionalStartPosition = null;</span>
      // adjusted minimum ignoreItem
<span class="fc" id="L377">      boolean adjustedMinimumIgnoreItem = false;</span>
      // fill queue if necessary and possible
<span class="fc bfc" id="L379" title="All 2 branches covered.">      for (int i = 0; i &lt; queueSpans.size(); i++) {</span>
<span class="fc" id="L380">        QueueItem item = queueSpans.get(i);</span>
        // if span is optional, check docId
<span class="pc bpc" id="L382" title="1 of 4 branches missed.">        if (!item.sequenceSpans.optional || (item.sequenceSpans.spans != null</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">            &amp;&amp; item.sequenceSpans.spans.docID() == docId)) {</span>
          // compute minimum startPosition until next non-optional item
          // used as lower boundary on endPosition next
<span class="fc" id="L386">          minStartPositionNext = null;</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">          for (int j = (i + 1); j &lt; queueSpans.size(); j++) {</span>

            // check for available lowestPosition
<span class="fc bfc" id="L390" title="All 4 branches covered.">            if (!queueSpans.get(j).sequenceSpans.optional &amp;&amp; queueSpans.get(j).lowestPosition != null) {</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">                minStartPositionNext = (minStartPositionNext == null)</span>
<span class="fc" id="L392">                    ? queueSpans.get(j).lowestPosition</span>
<span class="fc" id="L393">                    : Math.min(minStartPositionNext,</span>
<span class="fc" id="L394">                        queueSpans.get(j).lowestPosition);</span>
                // computing restrictions not possible
            } else {
<span class="fc bfc" id="L397" title="All 2 branches covered.">              if (!queueSpans.get(j).sequenceSpans.optional) {</span>
<span class="fc" id="L398">                minStartPositionNext = null;</span>
              }
              break;              
            }
          }
          // fill queue
<span class="fc bfc" id="L404" title="All 4 branches covered.">          if ((minStartPositionPrevious == null) || subMatchesOptional) {</span>
<span class="fc" id="L405">            fillQueue(item, null, maxEndPositionPrevious, minStartPositionNext);</span>
          } else {
<span class="fc" id="L407">            fillQueue(item, minStartPositionPrevious, maxEndPositionPrevious,</span>
                minStartPositionNext);
          }
          // try to adjust minimum ignoreItem
<span class="fc bfc" id="L411" title="All 4 branches covered.">          if (!adjustedMinimumIgnoreItem &amp;&amp; !item.sequenceSpans.optional</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">              &amp;&amp; item.filledPosition) {</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">            if (minOptionalStartPosition != null) {</span>
<span class="fc" id="L414">              ignoreItem.removeBefore(docId,</span>
<span class="fc" id="L415">                  Math.min(minOptionalStartPosition, item.lowestPosition));</span>
            } else {
<span class="fc" id="L417">              ignoreItem.removeBefore(docId, item.lowestPosition);</span>
            }
<span class="fc" id="L419">            adjustedMinimumIgnoreItem = true;</span>
          }
          // check for available positions
<span class="fc bfc" id="L422" title="All 4 branches covered.">          if (!item.sequenceSpans.optional &amp;&amp; item.noMorePositions</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">              &amp;&amp; !item.filledPosition) {</span>
<span class="fc" id="L424">            currentPosition = NO_MORE_POSITIONS;</span>
<span class="fc" id="L425">            return false;</span>
          }
          // build matches
<span class="fc" id="L428">          subMatchesQueue = _glue(subMatchesQueue, subMatchesOptional, item);</span>
          // update subMatchesOptional
<span class="fc bfc" id="L430" title="All 2 branches covered.">          if (!item.sequenceSpans.optional) {</span>
<span class="fc" id="L431">            subMatchesOptional = false;</span>
          }
          // check if matches are still achievable
<span class="fc bfc" id="L434" title="All 4 branches covered.">          if (!subMatchesOptional &amp;&amp; subMatchesQueue.isEmpty()) {</span>
            // clean up previous queues
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            if (subMatchesStartPosition != null) {</span>
<span class="fc" id="L437">              int cleanStartPosition = subMatchesStartPosition;</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">              for (int j = 0; j &lt;= i; j++) {</span>
<span class="fc" id="L439">                queueSpans.get(j).del(cleanStartPosition);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">                if (!queueSpans.get(j).sequenceSpans.optional) {</span>
<span class="fc" id="L441">                  cleanStartPosition++;</span>
                }
              }
            }
<span class="fc" id="L445">            return false;</span>
          }
          // update subMatchesStartPosition
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">          if (subMatchesQueue.isEmpty()) {</span>
<span class="nc" id="L449">            subMatchesStartPosition = null;</span>
          } else {
<span class="fc" id="L451">            subMatchesStartPosition = subMatchesQueue.get(0).startPosition;</span>
          }
          // compute minimum startPosition for next span
<span class="fc bfc" id="L454" title="All 2 branches covered.">          if (item.lowestPosition != null) {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">            minStartPositionPrevious = (minStartPositionPrevious == null)</span>
<span class="fc" id="L456">                ? item.lowestPosition</span>
<span class="fc" id="L457">                : Math.min(minStartPositionPrevious, item.lowestPosition);</span>
          }
          // for optional spans
<span class="fc bfc" id="L460" title="All 2 branches covered.">          if (item.sequenceSpans.optional) {</span>
            // update stats
<span class="fc bfc" id="L462" title="All 2 branches covered.">            if (item.lowestPosition != null) {</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">              minOptionalStartPosition = (minOptionalStartPosition == null)</span>
<span class="pc" id="L464">                  ? item.lowestPosition</span>
<span class="nc" id="L465">                  : Math.min(minOptionalStartPosition, item.lowestPosition);</span>
            }
            // for not optional spans
          } else {
            // update stats, item.lowestPosition should be set
<span class="fc bfc" id="L470" title="All 2 branches covered.">            minStartPosition = (minStartPosition == null) ? item.lowestPosition</span>
<span class="fc" id="L471">                : Math.min(minStartPosition, item.lowestPosition);</span>
            // reset maximum endPosition for next span
<span class="fc" id="L473">            maxEndPositionPrevious = null;</span>
          }
          // compute maximum endPosition for next span
<span class="fc bfc" id="L476" title="All 2 branches covered.">          if (item.lowestPosition != null) {</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">            for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">              maxEndPositionPrevious = (maxEndPositionPrevious == null)</span>
<span class="fc" id="L479">                  ? endPosition : Math.max(maxEndPositionPrevious, endPosition);</span>
<span class="fc" id="L480">            }</span>
          }
        }
      }
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">      if (subMatchesQueue.isEmpty()) {</span>
        // condition has only optional parts
<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (subMatchesOptional) {</span>
          // check for
<span class="nc" id="L488">          boolean allFinished = true;</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">          for (int i = 0; i &lt; queueSpans.size(); i++) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">            if (!queueSpans.get(i).noMorePositions) {</span>
<span class="nc" id="L491">              allFinished = false;</span>
<span class="nc" id="L492">              break;</span>
            }
          }
<span class="nc bnc" id="L495" title="All 2 branches missed.">          if (allFinished) {</span>
<span class="nc" id="L496">            currentPosition = NO_MORE_POSITIONS;</span>
          }
        }
<span class="nc" id="L499">        return false;</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">      } else if ((minOptionalStartPosition != null)</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">          &amp;&amp; (minOptionalStartPosition &lt; subMatchesStartPosition)) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        for (int i = 0; i &lt; queueSpans.size(); i++) {</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">          if (!queueSpans.get(i).sequenceSpans.optional) {</span>
<span class="nc" id="L504">            break;</span>
          } else {
<span class="nc" id="L506">            queueSpans.get(i).del(minOptionalStartPosition);</span>
          }
        }
<span class="nc" id="L509">        return false;</span>
      } else {
<span class="fc bfc" id="L511" title="All 2 branches covered.">        for (int i = 0; i &lt; queueSpans.size(); i++) {</span>
<span class="fc" id="L512">          queueSpans.get(i).del(subMatchesStartPosition);</span>
        }
<span class="fc bfc" id="L514" title="All 2 branches covered.">        for (Match m : subMatchesQueue) {</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">          if (!queueMatches.contains(m)) {</span>
<span class="fc" id="L516">            queueMatches.add(m);</span>
          }
<span class="fc" id="L518">        }</span>
<span class="fc" id="L519">        ignoreItem.removeBefore(docId, queueMatches.get(0).startPosition);</span>
<span class="fc" id="L520">        return true;</span>
      }
    }
  }

  /**
   * Glue.
   *
   * @param subMatchesQueue the sub matches queue
   * @param subMatchesOptional the sub matches optional
   * @param item the item
   * @return the list
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private List&lt;Match&gt; _glue(List&lt;Match&gt; subMatchesQueue,
      Boolean subMatchesOptional, QueueItem item) throws IOException {
<span class="fc" id="L536">    List&lt;Match&gt; newSubMatchesQueue = new ArrayList&lt;&gt;();</span>
    // no previous queue, only use current item
<span class="fc bfc" id="L538" title="All 2 branches covered.">    if (subMatchesQueue.isEmpty()) {</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">      if (item.filledPosition) {</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="fc" id="L541">          Match m = new Match(item.lowestPosition, endPosition);</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">          if (!newSubMatchesQueue.contains(m)) {</span>
<span class="fc" id="L543">            newSubMatchesQueue.add(m);</span>
          }
<span class="fc" id="L545">        }</span>
      }
<span class="fc" id="L547">      return newSubMatchesQueue;</span>
      // previous queue
    } else {
      // startposition from queue
<span class="fc" id="L551">      int startPosition = subMatchesQueue.get(0).startPosition;</span>
      // previous queue optional, current item optional
<span class="pc bpc" id="L553" title="1 of 4 branches missed.">      if (subMatchesOptional &amp;&amp; item.sequenceSpans.optional) {</span>
        // forget previous, because current has lower startposition
<span class="nc bnc" id="L555" title="All 4 branches missed.">        if (item.filledPosition &amp;&amp; item.lowestPosition &lt; startPosition) {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">          for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="nc" id="L557">            Match m = new Match(item.lowestPosition, endPosition);</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">            if (!newSubMatchesQueue.contains(m)) {</span>
<span class="nc" id="L559">              newSubMatchesQueue.add(m);</span>
            }
<span class="nc" id="L561">          }</span>
          // merge with previous
<span class="nc bnc" id="L563" title="All 2 branches missed.">        } else if (item.filledPosition) {</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">          if (item.lowestPosition.equals(startPosition)) {</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">            for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="nc" id="L566">              Match m = new Match(item.lowestPosition, endPosition);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">              if (!newSubMatchesQueue.contains(m)) {</span>
<span class="nc" id="L568">                newSubMatchesQueue.add(m);</span>
              }
<span class="nc" id="L570">            }</span>
          }
<span class="nc" id="L572">          newSubMatchesQueue.addAll(subMatchesQueue);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">          for (Match m : subMatchesQueue) {</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (item.queue.containsKey(m.endPosition)) {</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">              for (Integer endPosition : item.queue.get(m.endPosition)) {</span>
<span class="nc" id="L576">                Match o = new Match(m.startPosition, endPosition);</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">                if (!newSubMatchesQueue.contains(o)) {</span>
<span class="nc" id="L578">                  newSubMatchesQueue.add(o);</span>
                }
<span class="nc" id="L580">              }</span>
            }
<span class="nc" id="L582">          }</span>
          // no filled position
        } else {
<span class="nc" id="L585">          newSubMatchesQueue.addAll(subMatchesQueue);</span>
        }
        // previous queue optional, current item not optional
<span class="pc bpc" id="L588" title="1 of 4 branches missed.">      } else if (subMatchesOptional &amp;&amp; !item.sequenceSpans.optional) {</span>
<span class="pc bpc" id="L589" title="2 of 4 branches missed.">        assert item.filledPosition : &quot;span not optional, should contain items&quot;;</span>
        // forget previous
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">        if (item.lowestPosition &lt; startPosition) {</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">          for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="nc" id="L593">            Match m = new Match(item.lowestPosition, endPosition);</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (!newSubMatchesQueue.contains(m)) {</span>
<span class="nc" id="L595">              newSubMatchesQueue.add(m);</span>
            }
<span class="nc" id="L597">          }</span>
          // merge with previous
        } else {
<span class="fc bfc" id="L600" title="All 2 branches covered.">          if (item.lowestPosition.equals(startPosition)) {</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            for (Integer endPosition : item.queue.get(item.lowestPosition)) {</span>
<span class="fc" id="L602">              Match m = new Match(item.lowestPosition, endPosition);</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">              if (!newSubMatchesQueue.contains(m)) {</span>
<span class="fc" id="L604">                newSubMatchesQueue.add(m);</span>
              }
<span class="fc" id="L606">            }</span>
          }
<span class="fc bfc" id="L608" title="All 2 branches covered.">          for (Match m : subMatchesQueue) {</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">            if (item.queue.containsKey(m.endPosition)) {</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">              for (Integer endPosition : item.queue.get(m.endPosition)) {</span>
<span class="fc" id="L611">                Match o = new Match(m.startPosition, endPosition);</span>
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">                if (!newSubMatchesQueue.contains(o)) {</span>
<span class="fc" id="L613">                  newSubMatchesQueue.add(o);</span>
                }
<span class="fc" id="L615">              }</span>
            }
<span class="fc" id="L617">          }</span>
        }
        // previous queue not optional, current item optional
<span class="pc bpc" id="L620" title="1 of 4 branches missed.">      } else if (!subMatchesOptional &amp;&amp; item.sequenceSpans.optional) {</span>
<span class="fc" id="L621">        newSubMatchesQueue.addAll(subMatchesQueue);</span>
        // merge with previous
<span class="fc bfc" id="L623" title="All 2 branches covered.">        if (item.filledPosition) {</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">          for (Match m : subMatchesQueue) {</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (item.queue.containsKey(m.endPosition)) {</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">              for (Integer endPosition : item.queue.get(m.endPosition)) {</span>
<span class="fc" id="L627">                Match o = new Match(m.startPosition, endPosition);</span>
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">                if (!newSubMatchesQueue.contains(o)) {</span>
<span class="fc" id="L629">                  newSubMatchesQueue.add(o);</span>
                }
<span class="fc" id="L631">              }</span>
            }
<span class="fc" id="L633">          }</span>
        }
        // previous queue not optional, current item not optional
<span class="pc bpc" id="L636" title="2 of 4 branches missed.">      } else if (!subMatchesOptional &amp;&amp; !item.sequenceSpans.optional</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">          &amp;&amp; item.filledPosition) {</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        for (Match m : subMatchesQueue) {</span>
<span class="fc" id="L639">          HashSet&lt;Integer&gt; ignoreList = ignoreItem.getFullEndPositionList(docId,</span>
<span class="fc" id="L640">              m.endPosition);</span>
          Integer[] checkList;
<span class="fc bfc" id="L642" title="All 2 branches covered.">          if (ignoreList == null) {</span>
<span class="fc" id="L643">            checkList = new Integer[] { m.endPosition };</span>
          } else {
<span class="fc" id="L645">            checkList = new Integer[1 + ignoreList.size()];</span>
<span class="fc" id="L646">            checkList = ignoreList.toArray(checkList);</span>
<span class="fc" id="L647">            checkList[ignoreList.size()] = m.endPosition;</span>
          }
<span class="fc bfc" id="L649" title="All 2 branches covered.">          for (Integer checkEndPosition : checkList) {</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">            if (item.queue.containsKey(checkEndPosition)) {</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">              for (Integer endPosition : item.queue.get(checkEndPosition)) {</span>
<span class="fc" id="L652">                Match o = new Match(m.startPosition, endPosition);</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">                if (!newSubMatchesQueue.contains(o)) {</span>
<span class="fc" id="L654">                  newSubMatchesQueue.add(o);</span>
                }
<span class="fc" id="L656">              }</span>
            }
          }
<span class="fc" id="L659">        }</span>
      }
    }
<span class="fc" id="L662">    return newSubMatchesQueue;</span>
  }

  /**
   * Fill queue.
   *
   * @param item the item
   * @param minStartPosition the min start position
   * @param maxStartPosition the max start position
   * @param minEndPosition the min end position
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private void fillQueue(QueueItem item, Integer minStartPosition,
      Integer maxStartPosition, Integer minEndPosition) throws IOException {
    int newStartPosition;
    int newEndPosition;
<span class="fc" id="L678">    Integer firstRetrievedPosition = null;</span>
    // remove everything below minStartPosition
<span class="fc bfc" id="L680" title="All 4 branches covered.">    if ((minStartPosition != null) &amp;&amp; (item.lowestPosition != null)</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">        &amp;&amp; (item.lowestPosition &lt; minStartPosition)) {</span>
<span class="fc" id="L682">      item.del((minStartPosition - 1));</span>
    }
    // fill queue
<span class="fc bfc" id="L685" title="All 2 branches covered.">    while (!item.noMorePositions) {</span>
      boolean doNotCollectAnotherPosition;
<span class="fc bfc" id="L687" title="All 6 branches covered.">      doNotCollectAnotherPosition = item.filledPosition</span>
          &amp;&amp; (minStartPosition == null) &amp;&amp; (maxStartPosition == null);
<span class="fc bfc" id="L689" title="All 4 branches covered.">      doNotCollectAnotherPosition |= item.filledPosition</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">          &amp;&amp; (maxStartPosition != null) &amp;&amp; (item.lastRetrievedPosition != null)</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">          &amp;&amp; (maxStartPosition &lt; item.lastRetrievedPosition);</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">      if (doNotCollectAnotherPosition) {</span>
<span class="fc" id="L693">        return;</span>
      } else {
        // collect another full position
<span class="fc" id="L696">        firstRetrievedPosition = null;</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">        while (!item.noMorePositions) {</span>
<span class="fc" id="L698">          newStartPosition = item.sequenceSpans.spans.nextStartPosition();</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">          if (newStartPosition == NO_MORE_POSITIONS) {</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">            if (!item.queue.isEmpty()) {</span>
<span class="fc" id="L701">              item.filledPosition = true;</span>
<span class="fc" id="L702">              item.lastFilledPosition = item.lastRetrievedPosition;</span>
            }
<span class="fc" id="L704">            item.noMorePositions = true;</span>
<span class="fc" id="L705">            return;</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">          } else if ((minStartPosition != null)</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">              &amp;&amp; (newStartPosition &lt; minStartPosition)) {</span>
            // do nothing
          } else {
<span class="fc" id="L710">            newEndPosition = item.sequenceSpans.spans.endPosition();</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">            if ((minEndPosition == null) || (newEndPosition &gt;= minEndPosition</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">                - ignoreItem.getMinStartPosition(docId, newEndPosition))) {</span>
<span class="fc" id="L713">              item.add(newStartPosition, newEndPosition);</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">              if (firstRetrievedPosition == null) {</span>
<span class="fc" id="L715">                firstRetrievedPosition = newStartPosition;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">              } else if (!firstRetrievedPosition.equals(newStartPosition)) {</span>
<span class="fc" id="L717">                break;</span>
              }
            }
          }
        }
      }
<span class="fc" id="L723">    }</span>
<span class="fc" id="L724">  }</span>

  /**
   * Reset queue.
   */
  void resetQueue() {
<span class="fc" id="L730">    currentPosition = -1;</span>
<span class="fc" id="L731">    queueMatches.clear();</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">    for (QueueItem item : queueSpans) {</span>
<span class="fc" id="L733">      item.reset();</span>
<span class="fc" id="L734">    }</span>
<span class="fc" id="L735">    currentMatch = null;</span>
<span class="fc" id="L736">  }</span>

  /**
   * The Class QueueItem.
   */
  private static class QueueItem {

    /** The no more docs. */
    private boolean noMoreDocs;
    
    /** The no more positions. */
    private boolean noMorePositions;
    
    /** The filled position. */
    private boolean filledPosition;

    /** The lowest position. */
    private Integer lowestPosition;
    
    /** The last filled position. */
    private Integer lastFilledPosition;
    
    /** The last retrieved position. */
    private Integer lastRetrievedPosition;

    /** The queue. */
    private HashMap&lt;Integer, List&lt;Integer&gt;&gt; queue;

    /** The sequence spans. */
    public MtasSpanSequenceQuerySpans sequenceSpans;

    /**
     * Instantiates a new queue item.
     *
     * @param sequenceSpans the sequence spans
     */
<span class="fc" id="L772">    QueueItem(MtasSpanSequenceQuerySpans sequenceSpans) {</span>
<span class="fc" id="L773">      noMoreDocs = false;</span>
<span class="fc" id="L774">      this.sequenceSpans = sequenceSpans;</span>
<span class="fc" id="L775">      queue = new HashMap&lt;&gt;();</span>
<span class="fc" id="L776">      reset();</span>
<span class="fc" id="L777">    }</span>

    /**
     * Reset.
     */
    public void reset() {
<span class="fc" id="L783">      noMorePositions = false;</span>
<span class="fc" id="L784">      lowestPosition = null;</span>
<span class="fc" id="L785">      lastFilledPosition = null;</span>
<span class="fc" id="L786">      lastRetrievedPosition = null;</span>
<span class="fc" id="L787">      filledPosition = false;</span>
<span class="fc" id="L788">      queue.clear();</span>
<span class="fc" id="L789">    }</span>

    /**
     * Adds the.
     *
     * @param startPosition the start position
     * @param endPosition the end position
     */
    public void add(int startPosition, int endPosition) {
<span class="fc bfc" id="L798" title="All 2 branches covered.">      if (!queue.keySet().contains(startPosition)) {</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">        if (!queue.isEmpty()) {</span>
<span class="fc" id="L800">          filledPosition = true;</span>
<span class="fc" id="L801">          lastFilledPosition = lastRetrievedPosition;</span>
        }
<span class="fc" id="L803">        queue.put(startPosition, new ArrayList&lt;Integer&gt;());</span>
      }
<span class="fc" id="L805">      queue.get(startPosition).add(endPosition);</span>
<span class="pc bpc" id="L806" title="1 of 4 branches missed.">      if ((lowestPosition == null) || (lowestPosition &gt; startPosition)) {</span>
<span class="fc" id="L807">        lowestPosition = startPosition;</span>
      }
<span class="fc" id="L809">      lastRetrievedPosition = startPosition;</span>
<span class="fc" id="L810">    }</span>

    /**
     * Del.
     *
     * @param position the position
     */
    public void del(int position) {
<span class="fc" id="L818">      ArrayList&lt;Integer&gt; removePositions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">      for (int p : queue.keySet()) {</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">        if (p &lt;= position) {</span>
<span class="fc" id="L821">          removePositions.add(p);</span>
        }
<span class="fc" id="L823">      }</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">      if (!removePositions.isEmpty()) {</span>
        // positions.removeAll(removePositions);
<span class="fc bfc" id="L826" title="All 2 branches covered.">        for (int p : removePositions) {</span>
<span class="fc" id="L827">          queue.remove(p);</span>
<span class="fc" id="L828">        }</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">        if (queue.isEmpty()) {</span>
<span class="fc" id="L830">          lowestPosition = null;</span>
<span class="fc" id="L831">          lastFilledPosition = null;</span>
<span class="fc" id="L832">          filledPosition = false;</span>
        } else {
<span class="fc" id="L834">          lowestPosition = Collections.min(queue.keySet());</span>
<span class="pc bpc" id="L835" title="1 of 4 branches missed.">          if (filledPosition &amp;&amp; !queue.keySet().contains(lastFilledPosition)) {</span>
<span class="fc" id="L836">            lastFilledPosition = null;</span>
<span class="fc" id="L837">            filledPosition = false;</span>
          }
        }
      }
<span class="fc" id="L841">    }</span>
  }

  /**
   * The Class Match.
   */
  private static class Match {

    /** The start position. */
    private int startPosition;

    /** The end position. */
    private int endPosition;

    /**
     * Instantiates a new match.
     *
     * @param startPosition the start position
     * @param endPosition the end position
     */
<span class="fc" id="L861">    Match(int startPosition, int endPosition) {</span>
<span class="fc" id="L862">      this.startPosition = startPosition;</span>
<span class="fc" id="L863">      this.endPosition = endPosition;</span>
<span class="fc" id="L864">    }</span>

    /**
     * Start position.
     *
     * @return the int
     */
    public int startPosition() {
<span class="fc" id="L872">      return startPosition;</span>
    }

    /**
     * End position.
     *
     * @return the int
     */
    public int endPosition() {
<span class="fc" id="L881">      return endPosition;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">      if (this == obj)</span>
<span class="nc" id="L892">        return true;</span>
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">      if (obj == null)</span>
<span class="nc" id="L894">        return false;</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">      if (getClass() != obj.getClass())</span>
<span class="nc" id="L896">        return false;</span>
<span class="fc" id="L897">      final Match that = (Match) obj;</span>
<span class="pc bpc" id="L898" title="2 of 4 branches missed.">      return startPosition == that.startPosition</span>
          &amp;&amp; endPosition == that.endPosition;
    }

    /* (non-Javadoc)
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
<span class="nc" id="L907">      int h = this.getClass().getSimpleName().hashCode();</span>
<span class="nc" id="L908">      h = (h * 5) ^ startPosition;</span>
<span class="nc" id="L909">      h = (h * 7) ^ endPosition;</span>
<span class="nc" id="L910">      return h;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
<span class="nc" id="L920">      return &quot;[&quot; + startPosition + &quot;,&quot; + endPosition + &quot;]&quot;;</span>
    }

  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.DocIdSetIterator#cost()
   */
  @Override
  public long cost() {
<span class="nc" id="L932">    return cost;</span>
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.apache.lucene.search.spans.Spans#positionsCost()
   */
  @Override
  public float positionsCost() {
<span class="nc" id="L942">    return 0;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>