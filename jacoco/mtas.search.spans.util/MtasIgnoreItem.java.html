<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MtasIgnoreItem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MTAS</a> &gt; <a href="index.source.html" class="el_package">mtas.search.spans.util</a> &gt; <span class="el_source">MtasIgnoreItem.java</span></div><h1>MtasIgnoreItem.java</h1><pre class="source lang-java linenums">package mtas.search.spans.util;

import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;

import org.apache.lucene.search.spans.Spans;

/**
 * The Class MtasIgnoreItem.
 */
public class MtasIgnoreItem {
  
  /** The Constant DEFAULT_MAXIMUM_IGNORE_LENGTH. */
  public static final int DEFAULT_MAXIMUM_IGNORE_LENGTH = 10;

  /** The ignore spans. */
  Spans ignoreSpans;
  
  /** The current doc id. */
  int currentDocId;
  
  /** The current position. */
  int currentPosition;
  
  /** The minimum position. */
  int minimumPosition;
  
  /** The maximum ignore length. */
  int maximumIgnoreLength;
  
  /** The base start position list. */
  HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; baseStartPositionList;
  
  /** The base end position list. */
  HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; baseEndPositionList;
  
  /** The full end position list. */
  HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; fullEndPositionList;
  
  /** The min base start position. */
  HashMap&lt;Integer, Integer&gt; minBaseStartPosition;
  
  /** The max base end position. */
  HashMap&lt;Integer, Integer&gt; maxBaseEndPosition;
  
  /** The min full start position. */
  HashMap&lt;Integer, Integer&gt; minFullStartPosition;

/** The max full end position. */
HashMap&lt;Integer, Integer&gt; maxFullEndPosition;
  
  /**
   * Instantiates a new mtas ignore item.
   *
   * @param ignoreSpans the ignore spans
   * @param maximumIgnoreLength the maximum ignore length
   */
<span class="fc" id="L59">  public MtasIgnoreItem(Spans ignoreSpans, Integer maximumIgnoreLength) {</span>
<span class="fc" id="L60">    this.ignoreSpans = ignoreSpans;</span>
<span class="fc" id="L61">    currentDocId = -1;</span>
<span class="fc" id="L62">    currentPosition = -1;</span>
<span class="fc" id="L63">    minimumPosition = -1;</span>
<span class="fc" id="L64">    baseStartPositionList = new HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L65">    baseEndPositionList = new HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L66">    fullEndPositionList = new HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L67">    minBaseStartPosition = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="fc" id="L68">    maxBaseEndPosition = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="fc" id="L69">    minFullStartPosition = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="fc" id="L70">    maxFullEndPosition = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">    if (maximumIgnoreLength == null) {</span>
<span class="fc" id="L72">      this.maximumIgnoreLength = DEFAULT_MAXIMUM_IGNORE_LENGTH;</span>
    } else {
<span class="fc" id="L74">      this.maximumIgnoreLength = maximumIgnoreLength;</span>
    }
<span class="fc" id="L76">  }</span>

  /**
   * Advance to doc.
   *
   * @param docId the doc id
   * @return true, if successful
   * @throws IOException Signals that an I/O exception has occurred.
   */
  public boolean advanceToDoc(int docId) throws IOException {
<span class="pc bpc" id="L86" title="1 of 4 branches missed.">    if (ignoreSpans == null || currentDocId == Spans.NO_MORE_DOCS) {</span>
<span class="fc" id="L87">      return false;</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">    } else if (currentDocId == docId) {</span>
<span class="nc" id="L89">      return true;</span>
    } else {
<span class="fc" id="L91">      baseEndPositionList.clear();</span>
<span class="fc" id="L92">      fullEndPositionList.clear();</span>
<span class="fc" id="L93">      maxBaseEndPosition.clear();</span>
<span class="fc" id="L94">      minFullStartPosition.clear();</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">      if (currentDocId &lt; docId) {</span>
<span class="fc" id="L96">        currentDocId = ignoreSpans.advance(docId);</span>
<span class="fc" id="L97">        currentPosition = -1;</span>
<span class="fc" id="L98">        minimumPosition = -1;</span>
      }
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">      return currentDocId == docId;</span>
    }
  }

  /**
   * Gets the min start position.
   *
   * @param docId the doc id
   * @param position the position
   * @return the min start position
   * @throws IOException Signals that an I/O exception has occurred.
   */
  public int getMinStartPosition(int docId, int position) throws IOException {
<span class="pc bpc" id="L113" title="1 of 4 branches missed.">    if (ignoreSpans != null &amp;&amp; docId == currentDocId) {</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">      if (position &lt; minimumPosition) {</span>
<span class="nc" id="L115">        throw new IOException(</span>
            &quot;Unexpected position, should be &gt;= &quot; + minimumPosition + &quot;!&quot;);
      } else {
<span class="fc" id="L118">        computeFullStartPositionMinimum(position);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if(minFullStartPosition.containsKey(position)) {</span>
<span class="fc" id="L120">          return minFullStartPosition.get(position);</span>
        } else {
<span class="nc" id="L122">          return 0;</span>
        }
      }      
    } else {
<span class="fc" id="L126">      return 0;</span>
    }
  }
  
  /**
   * Gets the max end position.
   *
   * @param docId the doc id
   * @param position the position
   * @return the max end position
   * @throws IOException Signals that an I/O exception has occurred.
   */
  public int getMaxEndPosition(int docId, int position) throws IOException {
<span class="nc bnc" id="L139" title="All 4 branches missed.">    if (ignoreSpans != null &amp;&amp; docId == currentDocId) {</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">      if (position &lt; minimumPosition) {</span>
<span class="nc" id="L141">        throw new IOException(</span>
            &quot;Unexpected position, should be &gt;= &quot; + minimumPosition + &quot;!&quot;);
      }
<span class="nc" id="L144">      computeFullEndPositionList(position);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">      if(maxFullEndPosition.containsKey(position)) {</span>
<span class="nc" id="L146">        return maxFullEndPosition.get(position);</span>
      } else {
<span class="nc" id="L148">        return 0;</span>
      }
    } else {
<span class="nc" id="L151">      return 0;</span>
    }
  }

  /**
   * Gets the full end position list.
   *
   * @param docId the doc id
   * @param position the position
   * @return the full end position list
   * @throws IOException Signals that an I/O exception has occurred.
   */
  public HashSet&lt;Integer&gt; getFullEndPositionList(int docId, int position)
      throws IOException {
<span class="pc bpc" id="L165" title="1 of 4 branches missed.">    if (ignoreSpans != null &amp;&amp; docId == currentDocId) {</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">      if (position &lt; minimumPosition) {</span>
<span class="nc" id="L167">        throw new IOException(</span>
            &quot;Unexpected startPosition, should be &gt;= &quot; + minimumPosition + &quot;!&quot;);
      } else {
<span class="fc" id="L170">        computeFullEndPositionList(position);</span>
<span class="fc" id="L171">        return fullEndPositionList.get(position);</span>
      }
    } else {
<span class="fc" id="L174">      return null;</span>
    }
  }
  
  /**
   * Compute full start position minimum.
   *
   * @param position the position
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private void computeFullStartPositionMinimum(int position) throws IOException {
<span class="pc bpc" id="L185" title="2 of 4 branches missed.">    if (ignoreSpans != null &amp;&amp; !minFullStartPosition.containsKey(position)) {</span>
<span class="fc" id="L186">      HashSet&lt;Integer&gt; list = baseStartPositionList.get(position);</span>
<span class="fc" id="L187">      HashSet&lt;Integer&gt; newList = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L188">      int minimumStartPosition = position;</span>
<span class="pc bpc" id="L189" title="3 of 4 branches missed.">      while(list!=null &amp;&amp; !list.isEmpty()) {</span>
<span class="nc" id="L190">        newList.clear();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        for(int startPosition : list) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">          if(minFullStartPosition.containsKey(startPosition)) {</span>
<span class="nc" id="L193">            minimumStartPosition = Math.min(minimumStartPosition, minFullStartPosition.get(startPosition));</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">          } else if(baseStartPositionList.containsKey(startPosition)) {</span>
<span class="nc" id="L195">            newList.addAll(baseStartPositionList.get(startPosition));            </span>
          } else {
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if(startPosition&lt;minimumStartPosition) {</span>
<span class="nc" id="L198">              minimumStartPosition = startPosition;</span>
            }
          }
<span class="nc" id="L201">        }</span>
<span class="nc" id="L202">        list.clear();</span>
<span class="nc" id="L203">        list.addAll(newList);</span>
      }
<span class="fc" id="L205">      minFullStartPosition.put(position, minimumStartPosition);</span>
    }
<span class="fc" id="L207">  }  </span>

  /**
   * Compute full end position list.
   *
   * @param position the position
   * @throws IOException Signals that an I/O exception has occurred.
   */
  private void computeFullEndPositionList(int position) throws IOException {
<span class="pc bpc" id="L216" title="2 of 4 branches missed.">    if (ignoreSpans != null &amp;&amp; !fullEndPositionList.containsKey(position)) {</span>
      // initial fill
<span class="fc" id="L218">      moveTo(position);</span>
<span class="fc" id="L219">      HashSet&lt;Integer&gt; list = baseEndPositionList.get(position);</span>
<span class="pc bpc" id="L220" title="1 of 4 branches missed.">      if (list != null &amp;&amp; !list.isEmpty()) {</span>
<span class="fc" id="L221">        int maxEndPosition = maxBaseEndPosition.get(position);</span>
<span class="fc" id="L222">        HashSet&lt;Integer&gt; checkList = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L223">        HashSet&lt;Integer&gt; subCheckList = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L224">        checkList.addAll(list);</span>
<span class="fc" id="L225">        int depth = 1;</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        while (!checkList.isEmpty()) {</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">          if (depth &gt; maximumIgnoreLength) {</span>
<span class="nc" id="L228">            checkList.clear();</span>
<span class="nc" id="L229">            subCheckList.clear();</span>
<span class="nc" id="L230">            throw new IOException(&quot;too many successive ignores, maximum is &quot;</span>
                + maximumIgnoreLength);
          } else {
<span class="fc bfc" id="L233" title="All 2 branches covered.">            for (Integer checkItem : checkList) {</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">              if (fullEndPositionList.get(checkItem) != null) {</span>
<span class="nc" id="L235">                list.addAll(fullEndPositionList.get(checkItem));</span>
<span class="nc" id="L236">                maxEndPosition = Math.max(maxEndPosition,</span>
<span class="nc" id="L237">                    maxFullEndPosition.get(checkItem));</span>
              } else {
<span class="fc" id="L239">                moveTo(checkItem);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                if (baseEndPositionList.containsKey(checkItem)) {</span>
<span class="fc" id="L241">                  list.addAll(baseEndPositionList.get(checkItem));</span>
<span class="fc" id="L242">                  maxEndPosition = Math.max(maxEndPosition,</span>
<span class="fc" id="L243">                      maxBaseEndPosition.get(checkItem));</span>
<span class="fc" id="L244">                  subCheckList.addAll(baseEndPositionList.get(checkItem));</span>
                } else {
                  // ready for checkItem
                }
              }
<span class="fc" id="L249">            }</span>
<span class="fc" id="L250">            checkList.clear();</span>
<span class="fc" id="L251">            checkList.addAll(subCheckList);</span>
<span class="fc" id="L252">            subCheckList.clear();</span>
<span class="fc" id="L253">            depth++;</span>
          }
        }
<span class="fc" id="L256">        fullEndPositionList.put(position, list);</span>
<span class="fc" id="L257">        maxFullEndPosition.put(position, (maxEndPosition - position));</span>
<span class="fc" id="L258">      } else {</span>
<span class="fc" id="L259">        fullEndPositionList.put(position, null);</span>
<span class="fc" id="L260">        maxFullEndPosition.put(position, 0);</span>
      }
    }
<span class="fc" id="L263">  }</span>

  /**
   * Move to.
   *
   * @param position the position
   */
  private void moveTo(int position) {
<span class="fc bfc" id="L271" title="All 2 branches covered.">    while (position &gt;= currentPosition) {</span>
      try {
<span class="fc" id="L273">        currentPosition = ignoreSpans.nextStartPosition();</span>
<span class="fc bfc" id="L274" title="All 4 branches covered.">        if (currentPosition != Spans.NO_MORE_POSITIONS</span>
            &amp;&amp; currentPosition &gt;= minimumPosition) {
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">          if (!baseEndPositionList.containsKey(currentPosition)) {</span>
<span class="fc" id="L277">            baseEndPositionList.put(currentPosition, new HashSet&lt;Integer&gt;());</span>
<span class="fc" id="L278">            maxBaseEndPosition.put(currentPosition, currentPosition);</span>
          } else {
<span class="nc" id="L280">            maxBaseEndPosition.put(currentPosition,</span>
<span class="nc" id="L281">                Math.max(maxBaseEndPosition.get(currentPosition),</span>
<span class="nc" id="L282">                    ignoreSpans.endPosition()));  </span>
          }
<span class="fc bfc" id="L284" title="All 2 branches covered.">          if (!baseStartPositionList.containsKey(ignoreSpans.endPosition())) {</span>
<span class="fc" id="L285">            baseStartPositionList.put(ignoreSpans.endPosition(), new HashSet&lt;Integer&gt;());</span>
<span class="fc" id="L286">            minBaseStartPosition.put(ignoreSpans.endPosition(), ignoreSpans.endPosition());</span>
          } else {
<span class="fc" id="L288">            minBaseStartPosition.put(ignoreSpans.endPosition(),</span>
<span class="fc" id="L289">                Math.min(minBaseStartPosition.get(ignoreSpans.endPosition()),</span>
                    currentPosition)); 
          }
<span class="fc" id="L292">          baseStartPositionList.get(ignoreSpans.endPosition()).add(currentPosition); </span>
<span class="fc" id="L293">          baseEndPositionList.get(currentPosition).add(ignoreSpans.endPosition());                  </span>
        }
<span class="nc" id="L295">      } catch (IOException e) {</span>
<span class="nc" id="L296">        currentPosition = Spans.NO_MORE_POSITIONS;</span>
<span class="nc" id="L297">        break;</span>
<span class="fc" id="L298">      }</span>
    }
<span class="fc" id="L300">  }</span>

  /**
   * Removes the before.
   *
   * @param docId the doc id
   * @param position the position
   */
  public void removeBefore(int docId, int position) {
<span class="pc bpc" id="L309" title="1 of 4 branches missed.">    if (ignoreSpans != null &amp;&amp; docId == currentDocId) {</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">      baseStartPositionList.entrySet().removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">      baseEndPositionList.entrySet().removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">      fullEndPositionList.entrySet().removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc" id="L313">      minBaseStartPosition.entrySet()</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">          .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc" id="L315">      maxBaseEndPosition.entrySet()</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">      .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc" id="L317">      minFullStartPosition.entrySet()</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">      .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc" id="L319">      maxFullEndPosition.entrySet()</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">      .removeIf(entry -&gt; entry.getKey() &lt; position);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">      if (minimumPosition &lt; position) {</span>
<span class="fc" id="L322">        minimumPosition = position;</span>
      }
<span class="fc bfc" id="L324" title="All 2 branches covered.">      if (currentPosition &lt; position) {</span>
<span class="fc" id="L325">        currentPosition = position;</span>
      }
    }
<span class="fc" id="L328">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>